class t {
  constructor(...t) {
    const e = new Date(...t);
    if ("Invalid Date" === e.toString()) throw new TypeError("Invalid Date");
    if (e.getTime() > Date.now())
      throw new TypeError("Date of birth can only be in the past");
    this._dateOfBirth = e;
  }
  static of(t, e, r) {
    const a = new Date();
    return (
      a.setFullYear(a.getFullYear() - t),
      a.setHours(0, 0, 0, 0),
      "number" == typeof e && a.setMonth(a.getMonth() - e),
      "number" == typeof r && a.setDate(a.getDate() - r),
      void 0 === e && void 0 === r && a.setMonth(0, 0),
      new this(a)
    );
  }
  static parseDate(t) {
    return new this(Date.parse(t));
  }
  isBirthday(t = new Date()) {
    const e = new Date(t),
      r = this.dayOfBirth;
    return e.getMonth() === r.getMonth() && e.getDate() === r.getDate();
  }
  get dateOfBirth() {
    return new Date(this._dateOfBirth);
  }
  get dayOfBirth() {
    const t = new Date(this._dateOfBirth);
    return t.setHours(0, 0, 0, 0), t;
  }
  get value() {
    const t = new Date(),
      e = this.dateOfBirth;
    e.setFullYear(e.getFullYear() + 1);
    let r = 0;
    for (; e.getTime() < t.getTime(); ) e.setFullYear(e.getFullYear() + 1), r++;
    return r;
  }
  get daysBeforeBirthday() {
    const t = new Date();
    let e = 0;
    for (; !this.isBirthday(t); ) t.setDate(t.getDate() + 1), e++;
    return e;
  }
  [Symbol.toPrimitive](t) {
    return "string" === t ? this.toString() : this.valueOf();
  }
  valueOf() {
    return this.value;
  }
  toString(t) {
    return this.value.toString(t);
  }
  toJSON() {
    return this.value;
  }
  get [Symbol.toStringTag]() {
    return "Age";
  }
}
export { t as Age };
